[["introduction.html", "Report 1 Introduction", " Report Nathalie Lehmann 2021-08-29 1 Introduction We here present the analyses of ensGene. "],["data-pre-processing.html", " 2 Data pre-processing 2.1 Calculate QC metrics 2.2 Plot QC metrics 2.3 Filter data", " 2 Data pre-processing library(Seurat) library(dplyr) library(scater) library(gridExtra) library(RColorBrewer) library(cowplot) library(viridis) library(scales) library(ggthemes) We start by loading the Seurat object stored as a RDS object. It contains all the single-cell data. obj_seurat &lt;- readRDS(file = params$rds) obj_seurat[[&quot;orig.ident&quot;]] &lt;- params$gtf Idents(obj_seurat) &lt;- &#39;orig.ident&#39; At this step of the pre-processing, the data consists of 2481 cells and 19367 genes. Before going any further, we start by removing the genes that are not detected in our dataset (if any). obj_counts &lt;- obj_seurat@assays$RNA@counts features_keep &lt;- rowSums(obj_counts) &gt; 1 obj_seurat &lt;- obj_seurat[features_keep, ] table(features_keep) ## features_keep ## FALSE TRUE ## 1617 17750 There are 17750 remaining genes (detected at least twice). We now load a BioMart query table obtained from https://www.ensembl.org/biomart/martview. biomart &lt;- read.table(file = &#39;biomart.txt&#39;, header = TRUE, sep= &#39;\\t&#39;) 2.1 Calculate QC metrics In the following sections, we calculate the value of standard cell metrics and store it in the Seurat object. 2.1.1 Cells metrics 2.1.1.1 Mitochondrial genes genes_MT &lt;- biomart %&gt;% filter(Chromosome.scaffold.name == &quot;MT&quot;) %&gt;% filter(Gene.type == &quot;protein_coding&quot;) features &lt;- genes_MT[genes_MT$Gene.name %in% rownames(obj_seurat),&#39;Gene.name&#39;] if (length(features) != 0) { obj_seurat[[&quot;percent_MT&quot;]] &lt;- PercentageFeatureSet(obj_seurat, features = features) print(genes_MT$Gene.name) } else { obj_seurat[[&quot;percent_MT&quot;]] &lt;- 0 } ## [1] &quot;ATP6&quot; &quot;ATP6&quot; &quot;COII&quot; &quot;CYTB&quot; &quot;CYTB&quot; &quot;ATP8&quot; &quot;ATP8&quot; &quot;COX3&quot; ## [9] &quot;ND1&quot; &quot;MT-ND2&quot; &quot;MT-CO1&quot; &quot;ND3&quot; &quot;ND4L&quot; &quot;ND4&quot; &quot;ND5&quot; &quot;ND6&quot; 2.1.1.2 Ribosomal genes obj_seurat[[&#39;percent_Ribo&#39;]] &lt;- PercentageFeatureSet(obj_seurat, pattern = &quot;^RP[SL]&quot;) 2.1.1.3 Blood associated genes obj_seurat[[&#39;percent_Hb&#39;]] &lt;- PercentageFeatureSet(obj_seurat, pattern = &quot;^HB[^(P)]&quot;) 2.1.1.4 Percent of zeros in each cell obj_seurat[[&#39;percent_Dropouts&#39;]] &lt;- colSums(obj_counts == 0) / nrow(obj_counts)*100 2.1.2 Features metrics We now store genes metadata (e.g.Â number of cells in which the gene is detected, percent of zero counts, etc.) in the Seurat object. obj_counts &lt;- obj_seurat@assays$RNA@counts obj_seurat@assays$RNA@meta.features[[&#39;nCells_detected&#39;]] &lt;- rowSums(obj_counts != 0) obj_seurat@assays$RNA@meta.features[[&#39;percentCells_detected&#39;]] &lt;- rowSums(obj_counts != 0) / ncol(obj_counts)*100 obj_seurat@assays$RNA@meta.features[[&#39;total_counts&#39;]] &lt;- rowSums(obj_counts) obj_seurat@assays$RNA@meta.features[[&#39;log10_total_counts&#39;]] &lt;- log10(rowSums(obj_counts)) obj_seurat@assays$RNA@meta.features[[&#39;mean_counts&#39;]] &lt;- rowMeans(obj_counts) obj_seurat@assays$RNA@meta.features[[&#39;log10_mean_counts&#39;]] &lt;- log10(rowMeans(obj_counts)) obj_seurat@assays$RNA@meta.features[[&#39;percent_Dropouts&#39;]] &lt;- rowSums(obj_counts == 0) / ncol(obj_counts)*100 2.2 Plot QC metrics 2.2.1 Cells metrics 2.2.1.1 Violin plots metrics &lt;- c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent_MT&quot;, &quot;percent_Ribo&quot;, &quot;percent_Hb&quot;, &quot;percent_Dropouts&quot;) obj &lt;- as.data.frame(obj_seurat@meta.data[, metrics]) plots_colors &lt;- brewer.pal(6, &quot;Dark2&quot;) plots &lt;- list() for (i in seq(1, length(metrics))) { plots[[i]] &lt;- ggplot(obj, aes_string(x = factor(0), y = metrics[i])) + geom_violin(fill = plots_colors[i], alpha = 0.8) + geom_boxplot(width = 0.2, outlier.size = 0.5, outlier.alpha = 0.8) + labs(x = &quot;&quot;, y = &quot;&quot;, title = metrics[i]) + scale_x_discrete(labels = NULL, breaks = NULL) + theme_minimal() } do.call(grid.arrange, plots) 2.2.1.2 Histograms plots &lt;- list() for (i in seq(1, length(metrics))) { print(metrics[i]) print(summary(obj[,metrics[i]])) mu &lt;- mean(obj[,metrics[i]]) plots[[i]] &lt;- ggplot(obj, aes_string(x = metrics[i])) + geom_histogram(fill = plots_colors[i], alpha = 0.8, bins = 100) + labs(x = &quot;&quot;, y = &quot;&quot;, title = metrics[i]) + geom_vline(xintercept = mu, color = &quot;black&quot;, linetype = &quot;dashed&quot;, size = 0.8) + theme_minimal() } ## [1] &quot;nFeature_RNA&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 6 3704 4141 4176 4617 8788 ## [1] &quot;nCount_RNA&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 6 15506 18929 20568 23574 154755 ## [1] &quot;percent_MT&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00 10.99 12.21 12.86 13.82 68.97 ## [1] &quot;percent_Ribo&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00 18.45 20.04 20.14 22.07 37.36 ## [1] &quot;percent_Hb&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00000 0.03057 0.04210 0.26867 0.05671 60.19746 ## [1] &quot;percent_Dropouts&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 54.59 76.16 78.62 78.43 80.87 99.97 do.call(grid.arrange, plots) 2.2.1.3 nGenes against nCounts plots &lt;- list() for (i in seq(1, length(metrics))) { plots[[i]] &lt;- ggplot(obj, aes_string(x = &quot;nCount_RNA&quot;, y = &quot;nFeature_RNA&quot;, color = metrics[i])) + geom_point(size = 0.2, alpha = 0.8) + geom_rug(sides =&quot;bl&quot;) + scale_colour_gradientn(colours = rainbow(3)) } do.call(grid.arrange, plots) 2.2.2 Genes metrics 2.2.2.1 Violin plots metrics &lt;- c(&quot;nCells_detected&quot;, &quot;percentCells_detected&quot;, &quot;total_counts&quot;, &quot;log10_total_counts&quot;, &quot;mean_counts&quot;, &quot;log10_mean_counts&quot;, &quot;percent_Dropouts&quot;) obj &lt;- as.data.frame(obj_seurat@assays$RNA@meta.features[, metrics]) plots_colors &lt;- brewer.pal(7, &quot;Dark2&quot;) plots &lt;- list() for (i in seq(1, length(metrics))) { plots[[i]] &lt;- ggplot(obj, aes_string(x = factor(0), y = metrics[i])) + geom_violin(fill = plots_colors[i], alpha = 0.8) + geom_boxplot(width = 0.2, alpha = 0.3, outlier.size = 0.5, outlier.alpha = 0.8) + labs(x = &quot;&quot;, y = &quot;&quot;, title = metrics[i]) + scale_x_discrete(labels = NULL, breaks = NULL) + theme_minimal() } do.call(grid.arrange, plots) 2.2.2.2 Histograms plots &lt;- list() for (i in seq(1, length(metrics))) { print(metrics[i]) print(summary(obj[,metrics[i]])) mu &lt;- mean(obj[,metrics[i]]) plots[[i]] &lt;- ggplot(obj, aes_string(x = metrics[i])) + geom_histogram(fill = plots_colors[i], alpha = 0.8, bins = 100) + labs(x = &quot;&quot;, y = &quot;&quot;, title = metrics[i]) + geom_vline(xintercept = mu, color = &quot;black&quot;, linetype = &quot;dashed&quot;, size = 0.8) + theme_minimal() } ## [1] &quot;nCells_detected&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.0 16.0 186.0 583.7 1005.0 2479.0 ## [1] &quot;percentCells_detected&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.04031 0.64490 7.49698 23.52747 40.50786 99.91939 ## [1] &quot;total_counts&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2 17 212 2875 1507 949448 ## [1] &quot;log10_total_counts&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.301 1.230 2.326 2.235 3.178 5.977 ## [1] &quot;mean_counts&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0008 0.0069 0.0854 1.1588 0.6074 382.6876 ## [1] &quot;log10_mean_counts&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -3.0936 -2.1642 -1.0683 -1.1596 -0.2165 2.5828 ## [1] &quot;percent_Dropouts&quot; ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.08061 59.49214 92.50302 76.47253 99.35510 99.95969 do.call(grid.arrange, plots) 2.2.2.3 nCells against nCounts metrics &lt;- c(&quot;percent_Dropouts&quot;) plots &lt;- list() for (i in seq(1, length(metrics))) { plots[[i]] &lt;- ggplot(obj, aes_string(x = &quot;log10_total_counts&quot;, y = &quot;nCells_detected&quot;, color = metrics[i])) + geom_point(size = 0.2, alpha = 0.8) + geom_rug(sides =&quot;bl&quot;) + scale_colour_gradientn(colours = rev(rainbow(3))) } do.call(grid.arrange, plots) 2.2.3 Highly expressed genes obj_sce &lt;- as.SingleCellExperiment(obj_seurat) plotHighestExprs(obj_sce, n = 50, exprs_values = &quot;counts&quot;, colour_cells_by = &quot;percent_MT&quot;, as_percentage = TRUE) 2.3 Filter data 2.3.1 Cells filtering 2.3.1.1 By number of detected genes For the sake of simplicity, we keep cells in which we detect at least 1000 genes. We use the same threshold for all the datasets. md_cells &lt;- as.data.frame(obj_seurat@meta.data) table(md_cells$nFeature_RNA &gt;= 1000) ## ## FALSE TRUE ## 3 2478 quantile(md_cells$nFeature_RNA, probs = seq(0, 0.05, 0.01)) ## 0% 1% 2% 3% 4% 5% ## 6.0 2160.2 2619.8 2804.2 2935.0 3040.0 cells_keep &lt;- WhichCells(obj_seurat, expression = nFeature_RNA &gt;= 1000) obj_filt &lt;- subset(obj_seurat, cells = cells_keep) There are 2478 remaining cells. 2.3.1.2 By mitochondrial genes We here remove cells that express 20% or more of mitochondrial genes compared to the total number of genes detected in each of them. We chose the 20% threshold due to the distribution observed above. table(md_cells$percent_MT &lt; 20) ## ## FALSE TRUE ## 75 2406 quantile(md_cells$percent_MT, probs = seq(0.9, 1, 0.01)) ## 90% 91% 92% 93% 94% 95% 96% 97% ## 15.70165 15.91113 16.19067 16.64139 17.04488 17.71955 18.47223 20.09899 ## 98% 99% 100% ## 23.77213 31.67336 68.96623 cells_keep &lt;- WhichCells(obj_filt, expression = percent_MT &lt; 20) obj_filt &lt;- subset(obj_filt, cells = cells_keep) There are 2404 remaining cells. 2.3.1.3 Remove blood cells Blood cells are outliers in this dataset, so we need to remove them. For this purpose, we remove cells in which we detect 0.1% or more of blood associated genes (i.e.Â hemoglobin genes). table(md_cells$percent_Hb &lt; 0.1) ## ## FALSE TRUE ## 70 2411 quantile(md_cells$percent_Hb, probs = seq(0.9, 1, 0.01)) ## 90% 91% 92% 93% 94% 95% ## 0.07375175 0.07567897 0.07803725 0.08010904 0.08222058 0.08593834 ## 96% 97% 98% 99% 100% ## 0.09268938 0.09796861 0.11256679 0.15596915 60.19746475 cells_keep &lt;- WhichCells(obj_filt, expression = percent_Hb &lt; 0.1) obj_filt &lt;- subset(obj_filt, cells = cells_keep) There are 2353 remaining cells. 2.3.2 Genes filtering Finally, we filter the genes that are detected in less than 5 cells. min_genes &lt;- 1 min_cells &lt;- 5 features_keep &lt;- which(rowSums(obj_counts[rowSums(obj_counts) &gt;= min_genes,] != 0) &gt;= min_cells) obj_filt &lt;- subset(obj_filt, features = features_keep) Finally, there are 2353 remaining cells and 15680 remaining genes. saveRDS(obj_seurat, file = paste0(&quot;data/rds/&quot;, params$gtf, &quot;_obj_seurat_unfiltered.rds&quot;)) # Save metadata on cells write.table(obj_seurat[[]], file = paste0(&quot;data/raw/&quot;, params$gtf, &quot;_cells_metadata_unfiltered.tsv&quot;), quote = FALSE, sep = &quot;\\t&quot;) # Save metadata on genes write.table(obj_seurat@assays$RNA@meta.features, file = paste0(&quot;data/raw/&quot;, params$gtf, &quot;_genes_metadata_unfiltered.tsv&quot;), quote = FALSE, sep = &quot;\\t&quot;) obj_seurat &lt;- obj_filt "],["data-analyses.html", " 3 Data analyses 3.1 Data preparation to get scores 3.2 Identify populations 3.3 Assign cell-cycle scores 3.4 Summary plots 3.5 Biological analysis 3.6 Find variable genes 3.7 Clustering 3.8 Find DE genes between clusters 3.9 Find DE genes between subtypes 3.10 Find DE genes between SOX2+ and SOX2- populations 3.11 Save data", " 3 Data analyses 3.1 Data preparation to get scores This preparation step includes normalization, scaling of the data and identification of variable genes, which are performed in order to infer scores on cells (such as cell cycle). The normalization here is a simple log-normalization. A second normalization (with SCTransform), more robust to UMI-based datasets analyses, will be performed later on. obj_seurat &lt;- NormalizeData(obj_seurat, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) obj_seurat &lt;- ScaleData(obj_seurat, features = rownames(obj_seurat)) obj_seurat &lt;- FindVariableFeatures(obj_seurat, selection.method = &quot;vst&quot;) It also includes an inspection of the PCs to select an adequate number of PCs. obj_seurat &lt;- RunPCA(obj_seurat, features = VariableFeatures(object = obj_seurat), verbose = FALSE, npcs = 100) ElbowPlot(obj_seurat, ndims = 100) For the analyses to be comparable, we selected the same number of PCs for all of them and select the 25 first PCs. npc &lt;- 25 obj_seurat &lt;- RunPCA(obj_seurat, features = VariableFeatures(object = obj_seurat), verbose = FALSE, npcs = npc) obj_seurat &lt;- FindNeighbors(obj_seurat, dims = 1:npc) %&gt;% RunUMAP(dims = 1:npc) We will also define various colors palette for all the coming analyses. colors_pal1 &lt;- as.vector(yarrr::piratepal(&quot;appletv&quot;, plot.result = FALSE, trans = 0)[c(3,1,6)]) colors_pal2 &lt;- as.vector(brewer.pal(n = 4, name = &quot;Dark2&quot;)) colors_pal3 &lt;- as.vector(brewer.pal(n = 9, name = &quot;Paired&quot;)) colors_pal4 &lt;- ggthemes_data[[&quot;tableau&quot;]][[&quot;color-palettes&quot;]][[&quot;regular&quot;]][[&quot;Classic 20&quot;]] colors_pal4 &lt;- as.vector(colors_pal4$value) colors_pal &lt;- list(Phase = colors_pal1, Cell_type = colors_pal2, Cell_subtype = colors_pal3, Clusters = colors_pal4) names(colors_pal[[1]]) &lt;- c(&#39;G1&#39;, &#39;G2M&#39;, &#39;S&#39;) names(colors_pal[[2]]) &lt;- c(&#39;Progenitor&#39;, &#39;Neuron&#39;, &#39;Neural_crest&#39;, &#39;Mesoderm&#39;) names(colors_pal[[3]]) &lt;- c(&#39;RP&#39;, &#39;dp&#39;, &#39;p&#39;, &#39;pMN&#39;, &#39;p3&#39;, &#39;FP&#39;, &#39;Neuron&#39;, &#39;Neural_crest&#39;, &#39;Mesoderm&#39;) names(colors_pal[[4]]) &lt;- paste0(&#39;clust_&#39;, 1:20) # Save color palettes write.table(obj_seurat[[]], file = paste0(&quot;data/raw/&quot;, params$gtf, &quot;_colors_palette.tsv&quot;), quote = FALSE, sep = &quot;\\t&quot;) 3.2 Identify populations The cells used in this dataset come from chick embryo neural tube dissection. We thus expect to find mostly neural progenitors and early neurons. However, during dissection, some adjacent cells are difficult to clean from the neural tube. We might find also blood, mesoderm and neural crest cells in our dataset, besides neurons and progenitors. In the following step, we use a set of neurogenesis markers to identify cells in our dataset. Specifically, our main markers are on one side SOX2 (a pan-progenitor marker), and on the other side TUBB3, a marker of neurons. We use different strategies to identify our cell populations. First, a minimalist one just based on SOX2 expression. The reason for this is that most of the cells in the datasets are supposed to be neural progenitors, which express SOX2. This first classification will simply separate cells into SOX2+ (progenitors) and SOX2- (non-progenitors) populations. The non-progenitor population actually include the neurons, mesoderm and neural crest. Second, a more advanced classification is performed based on a set of marker genes. For this purpose, we use the table of marker genes provided in the mouse spinal cord atlas from Delile et al.Â (2019). In this classification, cells are classified into progenitors, neurons, neural crest and mesoderm. Finally, we use a deeper level of classification for progenitors, according to the progenitors classification from Delile et al.Â (2019). See below for more details. 3.2.1 Get stats on some marker genes features &lt;- c(&#39;SOX2&#39;, &#39;TUBB3&#39;, &#39;PAX6&#39;, &#39;PAX7&#39;, &#39;ISL1&#39;, &#39;ISL2&#39;, &#39;NKX6-2&#39;, &#39;OLIG2&#39;, &#39;SHH&#39;, &#39;PRDM8&#39;, &#39;TWIST1&#39;, &#39;SOX10&#39;) # Get quick access to metadata on genes md_genes &lt;- obj_seurat@assays$RNA@meta.features # Check if features are in the dataset features &lt;- features[which(features %in% row.names(md_genes))] print(features) ## [1] &quot;SOX2&quot; &quot;TUBB3&quot; &quot;PAX6&quot; &quot;PAX7&quot; &quot;ISL1&quot; &quot;ISL2&quot; &quot;NKX6-2&quot; &quot;OLIG2&quot; ## [9] &quot;SHH&quot; &quot;PRDM8&quot; &quot;TWIST1&quot; &quot;SOX10&quot; # Print metadata of these selected genes DT::datatable(md_genes[features,], extensions = c(&#39;Buttons&#39;, &#39;Scroller&#39;), options = list( dom = &#39;Bfrtip&#39;, buttons = c(&#39;csv&#39;, &#39;pdf&#39;), deferRender = TRUE, scrollY = 200, scrollX = TRUE, scroller = TRUE)) 3.2.2 Plot UMAP of marker genes plots &lt;- list() for (i in seq(1, length(features))) { plots[[i]] &lt;- FeaturePlot(obj_seurat, features = features[i], cols = c(&quot;grey90&quot;, rev(brewer.pal(5, &quot;Spectral&quot;))), pt.size = 0.2, ncol = 1) + NoLegend() } for (i in seq(1, length(features), 4)) { if (c(i+3) &lt;= length(features)) { do.call(grid.arrange, c(plots[i:c(i+3)], ncol = 2, nrow = 2)) } else { do.call(grid.arrange, c(plots[i:length(features)], ncol = 2, nrow = 2)) } } 3.2.3 Classify cells based on known markers 3.2.3.1 Identify cell types We here use markers genes defined in Delile et al.Â (2019) to identify progenitors, neurons and mesoderm cells. pop_markers &lt;- read.table(file = &#39;TableS1.csv&#39;, header = TRUE, sep = &#39;;&#39;, row.names = 1) rownames(pop_markers) &lt;- toupper(rownames(pop_markers)) markers_genes &lt;- list(Progenitor = c(&#39;SOX2&#39;, rownames(pop_markers)[1:26]) , Neuron = c(&#39;TUBB3&#39;, &#39;ELAVL3&#39;, rownames(pop_markers)[27:54]), Neural_crest = c(&#39;SOX10&#39;, &#39;TPM1&#39;, &#39;LMO4&#39;, &#39;NPR3&#39;), Mesoderm = c(&#39;FOXC1&#39;, &#39;FOXC2&#39;, &#39;TWIST1&#39;, &#39;TWIST2&#39;, &#39;MEOX1&#39;, &#39;MEXO2&#39;)) indices_to_remove &lt;- c() j &lt;- 1 for (i in seq(1, length(markers_genes))) { markers_genes[[i]] &lt;- markers_genes[[i]][which(markers_genes[[i]] %in% rownames(obj_seurat))] if(length(markers_genes[[i]]) &gt; 1) { obj_seurat &lt;- AddModuleScore(obj_seurat, features = markers_genes[i], pool = NULL, nbin = 5, seed = 1, ctrl = length(markers_genes[i]), k = FALSE, name = names(markers_genes[i])) col_name &lt;- names(markers_genes)[[i]] col_name_val &lt;- which(colnames(obj_seurat[[]]) == paste0(col_name, 1)) colnames(obj_seurat@meta.data)[col_name_val] &lt;- col_name } else { indices_to_remove[j] &lt;- i j &lt;- j + 1 } } markers_genes[indices_to_remove] &lt;- NULL print(markers_genes) ## $Progenitor ## [1] &quot;SOX2&quot; &quot;LMX1A&quot; &quot;MSX1&quot; &quot;MSX2&quot; &quot;PAX3&quot; &quot;WNT1&quot; &quot;IRX3&quot; &quot;IRX5&quot; ## [9] &quot;PAX6&quot; &quot;PAX7&quot; &quot;GSX2&quot; &quot;ASCL1&quot; &quot;GBX2&quot; &quot;GSX1&quot; &quot;DBX2&quot; &quot;SP8&quot; ## [17] &quot;NKX6-2&quot; &quot;PRDM12&quot; &quot;NKX6-1&quot; &quot;FOXN4&quot; &quot;OLIG2&quot; &quot;NKX2-2&quot; &quot;FOXA2&quot; &quot;FERD3L&quot; ## ## $Neuron ## [1] &quot;TUBB3&quot; &quot;ARX&quot; &quot;SHH&quot; &quot;LMX1B&quot; &quot;FOXD3&quot; &quot;LHX1&quot; &quot;LHX5&quot; ## [8] &quot;ISL1&quot; &quot;TLX3&quot; &quot;OTP&quot; &quot;LBX1&quot; &quot;PAX2&quot; &quot;GBX1&quot; &quot;BHLHE22&quot; ## [15] &quot;PTF1A&quot; &quot;WT1&quot; &quot;EVX1&quot; &quot;PITX2&quot; &quot;EN1&quot; ## ## $Neural_crest ## [1] &quot;SOX10&quot; &quot;TPM1&quot; &quot;LMO4&quot; &quot;NPR3&quot; ## ## $Mesoderm ## [1] &quot;FOXC1&quot; &quot;FOXC2&quot; &quot;TWIST1&quot; &quot;TWIST2&quot; &quot;MEOX1&quot; # Update colors according to cell types found in the dataset colors_pal$Cell_type &lt;- colors_pal$Cell_type[names(markers_genes)] for (f in names(markers_genes)){ print(FeaturePlot(obj_seurat, features = f, dims = c(1, 2), cols = c(&quot;grey90&quot;, brewer.pal(9,&quot;YlGnBu&quot;)), pt.size = 0.2, ncol = 1) + NoLegend()) } In order to assign a type to each cell, we take the highest value between each score among the scores of progenitors, neurons, mesoderm and neural crest. names_cols &lt;- c(names(markers_genes)) md_cells &lt;- obj_seurat@meta.data obj_seurat@meta.data$Cell_type &lt;- colnames(md_cells[,names_cols])[max.col(md_cells[,names_cols], ties.method = &quot;first&quot;)] #types_levels &lt;- c(&#39;Progenitor&#39;, &#39;Neuron&#39;, &#39;Neural_crest&#39;, &#39;Mesoderm&#39;) obj_seurat@meta.data$Cell_type &lt;- factor(x = obj_seurat@meta.data$Cell_type, levels = names_cols) Idents(obj_seurat) &lt;- &#39;Cell_type&#39; table(obj_seurat@meta.data$Cell_type) ## ## Progenitor Neuron Neural_crest Mesoderm ## 968 433 581 371 DimPlot(obj_seurat, reduction = &quot;umap&quot;, dims = c(1, 2), label = FALSE, cols = colors_pal$Cell_type, label.size = 4, pt.size = 0.2) 3.2.3.2 Identify cell subtypes Now we look for progenitors subtypes. We follow the same process as above for the cell assignment. markers_genes &lt;- list(RP = rownames(pop_markers[which(pop_markers$RP == 1),]), dp = c(rownames(pop_markers)[2:4], rownames(pop_markers)[6:15]), p = c(rownames(pop_markers)[6:8], rownames(pop_markers)[14:19]), pMN = rownames(pop_markers[which(pop_markers$pMN == 1),]), p3 = rownames(pop_markers[which(pop_markers$p3 == 1),]), FP = rownames(pop_markers[which(pop_markers$FP == 1),])) indices_to_remove &lt;- c() j &lt;- 1 for (i in seq(1, length(markers_genes))) { markers_genes[[i]] &lt;- markers_genes[[i]][which(markers_genes[[i]] %in% rownames(obj_seurat))] if(length(markers_genes[[i]]) &gt; 1) { obj_seurat &lt;- AddModuleScore(obj_seurat, features = markers_genes[i], pool = NULL, nbin = 5, seed = 1, ctrl = length(markers_genes[i]), k = FALSE, name = names(markers_genes[i])) col_name &lt;- names(markers_genes)[[i]] col_name_val &lt;- which(colnames(obj_seurat[[]]) == paste0(col_name, 1)) colnames(obj_seurat@meta.data)[col_name_val] &lt;- col_name } else { indices_to_remove[j] &lt;- i j &lt;- j + 1 } } markers_genes[indices_to_remove] &lt;- NULL print(markers_genes) ## $RP ## [1] &quot;LMX1A&quot; &quot;MSX1&quot; &quot;MSX2&quot; &quot;PAX3&quot; &quot;WNT1&quot; ## ## $dp ## [1] &quot;MSX1&quot; &quot;MSX2&quot; &quot;PAX3&quot; &quot;IRX3&quot; &quot;IRX5&quot; &quot;PAX6&quot; &quot;PAX7&quot; &quot;GSX2&quot; &quot;ASCL1&quot; ## [10] &quot;GBX2&quot; &quot;GSX1&quot; &quot;DBX2&quot; ## ## $p ## [1] &quot;IRX3&quot; &quot;IRX5&quot; &quot;GSX1&quot; &quot;DBX2&quot; &quot;SP8&quot; &quot;NKX6-2&quot; &quot;PRDM12&quot; ## ## $pMN ## [1] &quot;SP8&quot; &quot;NKX6-1&quot; &quot;OLIG2&quot; ## ## $p3 ## [1] &quot;NKX6-1&quot; &quot;NKX2-2&quot; ## ## $FP ## [1] &quot;NKX6-1&quot; &quot;FOXA2&quot; &quot;FERD3L&quot; &quot;ARX&quot; &quot;SHH&quot; &quot;LMX1B&quot; # Update colors according to cell types found in the dataset names_cols &lt;- c(names(markers_genes), c(levels(obj_seurat@meta.data$Cell_type))) names_cols &lt;- names_cols[-which(names_cols == &quot;Progenitor&quot;)] colors_pal$Cell_subtype &lt;- colors_pal$Cell_subtype[names_cols] for (f in names(markers_genes)){ print(FeaturePlot(obj_seurat, features = f, dims = c(1, 2), cols = c(&quot;grey90&quot;, brewer.pal(9,&quot;YlGnBu&quot;)), pt.size = 0.2, ncol = 1) + NoLegend()) } md_cells &lt;- obj_seurat@meta.data obj_seurat@meta.data$Cell_subtype &lt;- colnames(md_cells[,names_cols])[max.col(md_cells[,names_cols], ties.method = &quot;first&quot;)] #subtypes_levels &lt;- c(&#39;RP&#39;, &#39;dp&#39;, &#39;p&#39;, &#39;pMN&#39;, &#39;p3&#39;, &#39;FP&#39;, &#39;Neuron&#39;, &#39;Neural_crest&#39;, &#39;Mesoderm&#39;) obj_seurat@meta.data$Cell_subtype &lt;- factor(x = obj_seurat@meta.data$Cell_subtype, levels = names_cols) Idents(obj_seurat) &lt;- &#39;Cell_subtype&#39; table(obj_seurat@meta.data$Cell_subtype) ## ## RP dp p pMN p3 FP ## 326 450 158 435 218 46 ## Neuron Neural_crest Mesoderm ## 138 286 296 DimPlot(obj_seurat, reduction = &quot;umap&quot;, dims = c(1, 2), label = FALSE, cols = colors_pal$Cell_subtype, label.size = 4, pt.size = 0.2) 3.2.4 Assign cell status depending on SOX2 expression Most of the cells in this dataset are expected to be neural progenitors. They are thus expected to express SOX2. We assign a score 1 to cells in which we detect SOX2 (progenitors), 0 to the others (non-progenitors). obj_seurat[[&#39;SOX2_value&#39;]] &lt;- obj_seurat@assays$RNA@counts[&#39;SOX2&#39;,] # Value of SOX2 (distribution of the quantity detected in each cell in raw count) table(obj_seurat@meta.data$SOX2_value) ## ## 0 1 2 3 4 5 ## 1865 387 77 20 2 2 ggplot(obj_seurat@meta.data, aes(x = factor(SOX2_value))) + geom_bar(fill = &quot;steelblue&quot;) + labs(x = &quot;SOX2 raw count&quot;) + theme_minimal() # SOX2 classification df_sox2 &lt;- ifelse(obj_seurat[[]][&#39;SOX2_value&#39;] &gt; 0, 1, 0) colnames(df_sox2) &lt;- &quot;SOX2_status&quot; obj_seurat@meta.data$SOX2_status &lt;- as.factor(df_sox2) # Cells amount according to SOX2 status table(df_sox2) ## df_sox2 ## 0 1 ## 1865 488 3.3 Assign cell-cycle scores We use the function CellCycleScoring of Seurat to assign a cell cycle phase to each cell. The genes used for this classification are printed just below (s.genes and g2m.genes). s.genes &lt;- cc.genes.updated.2019[[&#39;s.genes&#39;]][which(cc.genes.updated.2019[[&#39;s.genes&#39;]] %in% rownames(obj_seurat))] g2m.genes &lt;- cc.genes.updated.2019[[&#39;g2m.genes&#39;]][which(cc.genes.updated.2019[[&#39;g2m.genes&#39;]] %in% rownames(obj_seurat))] print(s.genes) ## [1] &quot;MCM5&quot; &quot;PCNA&quot; &quot;FEN1&quot; &quot;MCM4&quot; &quot;RRM1&quot; &quot;UNG&quot; ## [7] &quot;GINS2&quot; &quot;MCM6&quot; &quot;DTL&quot; &quot;UHRF1&quot; &quot;CENPU&quot; &quot;HELLS&quot; ## [13] &quot;RFC2&quot; &quot;POLR1B&quot; &quot;NASP&quot; &quot;GMNN&quot; &quot;WDR76&quot; &quot;SLBP&quot; ## [19] &quot;CCNE2&quot; &quot;UBR7&quot; &quot;POLD3&quot; &quot;MSH2&quot; &quot;ATAD2&quot; &quot;RAD51&quot; ## [25] &quot;RRM2&quot; &quot;CDC45&quot; &quot;CDC6&quot; &quot;EXO1&quot; &quot;TIPIN&quot; &quot;DSCC1&quot; ## [31] &quot;BLM&quot; &quot;CASP8AP2&quot; &quot;USP1&quot; &quot;CLSPN&quot; &quot;POLA1&quot; &quot;CHAF1B&quot; ## [37] &quot;E2F8&quot; print(g2m.genes) ## [1] &quot;HMGB2&quot; &quot;CDK1&quot; &quot;NUSAP1&quot; &quot;UBE2C&quot; &quot;BIRC5&quot; &quot;TPX2&quot; &quot;TOP2A&quot; ## [8] &quot;NDC80&quot; &quot;CKS2&quot; &quot;NUF2&quot; &quot;CKS1B&quot; &quot;TMPO&quot; &quot;CENPF&quot; &quot;TACC3&quot; ## [15] &quot;SMC4&quot; &quot;CKAP2L&quot; &quot;CKAP2&quot; &quot;BUB1&quot; &quot;KIF11&quot; &quot;ANP32E&quot; &quot;TUBB4B&quot; ## [22] &quot;GTSE1&quot; &quot;HJURP&quot; &quot;CDCA3&quot; &quot;CDC20&quot; &quot;TTK&quot; &quot;KIF2C&quot; &quot;RANGAP1&quot; ## [29] &quot;NCAPD2&quot; &quot;DLGAP5&quot; &quot;ECT2&quot; &quot;KIF23&quot; &quot;HMMR&quot; &quot;AURKA&quot; &quot;ANLN&quot; ## [36] &quot;LBR&quot; &quot;CKAP5&quot; &quot;CENPE&quot; &quot;CTCF&quot; &quot;NEK2&quot; &quot;G2E3&quot; &quot;GAS2L3&quot; obj_seurat &lt;- CellCycleScoring(obj_seurat, s.features = s.genes, g2m.features = g2m.genes, set.ident = FALSE) obj_seurat@meta.data$Phase &lt;- as.factor(obj_seurat@meta.data$Phase) obj_seurat$CC.Difference &lt;- obj_seurat$S.Score - obj_seurat$G2M.Score DimPlot(obj_seurat, reduction = &quot;umap&quot;, dims = c(1, 2), group.by = &quot;Phase&quot;, cols = colors_pal$Phase, label = FALSE, label.size = 4, pt.size = 0.2) 3.4 Summary plots features &lt;- c(unique(unlist(markers_genes))) # CC Phase x &lt;- &#39;Phase&#39; table(obj_seurat[[]][x]) ## ## G1 G2M S ## 847 763 743 prop.table(table(obj_seurat[[]][x])) ## ## G1 G2M S ## 0.3599660 0.3242669 0.3157671 Idents(obj_seurat) &lt;- x DotPlot(obj_seurat, features = features) + RotatedAxis() + scale_colour_gradient2(low = &quot;blue&quot;, mid = &quot;lightgray&quot;, high = &quot;red&quot;) + theme(axis.text.x = element_text(size = 8)) + labs(x = &quot;&quot;, y = &quot;&quot;) ggplot(obj_seurat[[]], aes_string(x = &#39;orig.ident&#39;, fill = x)) + geom_bar(aes(y = (..count..)/sum(..count..))) + scale_fill_manual(values = colors_pal$Phase) + theme_minimal() + scale_y_continuous(labels = percent) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Proportion of cells in each cell cycle phase&quot;) # Cell types x &lt;- &#39;Cell_type&#39; table(obj_seurat[[]][x]) ## ## Progenitor Neuron Neural_crest Mesoderm ## 968 433 581 371 prop.table(table(obj_seurat[[]][x])) ## ## Progenitor Neuron Neural_crest Mesoderm ## 0.4113897 0.1840204 0.2469188 0.1576711 Idents(obj_seurat) &lt;- x DotPlot(obj_seurat, features = features) + RotatedAxis() + scale_colour_gradient2(low = &quot;blue&quot;, mid = &quot;lightgray&quot;, high = &quot;red&quot;) + theme(axis.text.x = element_text(size = 8)) + labs(x = &quot;&quot;, y = &quot;&quot;) ggplot(obj_seurat[[]], aes_string(x = &#39;orig.ident&#39;, fill = x)) + geom_bar(aes(y = (..count..)/sum(..count..))) + scale_fill_manual(values = colors_pal$Cell_type) + theme_minimal() + scale_y_continuous(labels = percent) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Proportion of progenitors and neurons&quot;) # Cell subtypes x &lt;- &#39;Cell_subtype&#39; table(obj_seurat[[]][x]) ## ## RP dp p pMN p3 FP ## 326 450 158 435 218 46 ## Neuron Neural_crest Mesoderm ## 138 286 296 prop.table(table(obj_seurat[[]][x])) ## ## RP dp p pMN p3 FP ## 0.13854654 0.19124522 0.06714832 0.18487038 0.09264768 0.01954951 ## Neuron Neural_crest Mesoderm ## 0.05864853 0.12154696 0.12579686 Idents(obj_seurat) &lt;- x DotPlot(obj_seurat, features = features) + RotatedAxis() + scale_colour_gradient2(low = &quot;blue&quot;, mid = &quot;lightgray&quot;, high = &quot;red&quot;) + theme(axis.text.x = element_text(size = 8)) + labs(x = &quot;&quot;, y = &quot;&quot;) ggplot(obj_seurat[[]], aes_string(x = &#39;orig.ident&#39;, fill = x)) + geom_bar(aes(y = (..count..)/sum(..count..))) + scale_fill_manual(values = colors_pal$Cell_subtype) + theme_minimal() + scale_y_continuous(labels = percent) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Proportion of subtypes&quot;) # SOX2 status x &lt;- &#39;SOX2_status&#39; table(obj_seurat[[]][x]) ## ## 0 1 ## 1865 488 prop.table(table(obj_seurat[[]][x])) ## ## 0 1 ## 0.7926052 0.2073948 Idents(obj_seurat) &lt;- x DotPlot(obj_seurat, features = features) + RotatedAxis() + scale_colour_gradient2(low = &quot;blue&quot;, mid = &quot;lightgray&quot;, high = &quot;red&quot;) + theme(axis.text.x = element_text(size = 8)) + labs(x = &quot;&quot;, y = &quot;&quot;) ggplot(obj_seurat[[]], aes_string(x = &#39;orig.ident&#39;, fill = x)) + geom_bar(aes(y = (..count..)/sum(..count..))) + scale_fill_viridis(discrete = T) + theme_minimal() + scale_y_continuous(labels = percent) + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;Proportion of SOX2+ / SOX2- cells&quot;) 3.5 Biological analysis From now-on, the data of the previous normalization will not be used anymore. It was a quick and basic normalization used only to pre-process the data. For the next steps, we will use an improved (but more time-consuming) normalization strategy with SCTransform. This approach removes the need for heuristic steps such as pseudocount addition or log-transformation. We also regress out the differences between cycling and non cycling cells. obj_seurat &lt;- SCTransform(object = obj_seurat, vars.to.regress = c(&quot;CC.Difference&quot;), do.scale = TRUE, verbose = FALSE) 3.6 Find variable genes obj_seurat &lt;- FindVariableFeatures(obj_seurat, selection.method = &quot;vst&quot;, nfeatures = 2000) top10 &lt;- head(VariableFeatures(obj_seurat), 10) plot1 &lt;- VariableFeaturePlot(obj_seurat) plot2 &lt;- LabelPoints(plot = plot1, points = top10, repel = TRUE) plot2 3.7 Clustering We cluster the cells based on Louvain algorithm. We set the clustering resolution to 0.5 for all the samples for comparison purposes. obj_seurat &lt;- RunPCA(obj_seurat, verbose = FALSE) %&gt;% RunUMAP(dims = 1:npc, verbose = FALSE) %&gt;% FindNeighbors(dims = 1:npc) %&gt;% FindClusters(resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 2353 ## Number of edges: 75071 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8909 ## Number of communities: 12 ## Elapsed time: 0 seconds Idents(obj_seurat) &lt;- &#39;seurat_clusters&#39; DimPlot(obj_seurat, reduction = &quot;umap&quot;, dims = c(1, 2), group.by = &quot;seurat_clusters&quot;, cols = as.vector(colors_pal$Clusters), label = FALSE, label.size = 4, pt.size = 0.2) 3.7.1 Plot marker genes for each cluster plots &lt;- list() for (i in seq(1, length(features))) { plots[[i]] &lt;- VlnPlot(obj_seurat, features = features[i], cols = as.vector(colors_pal$Clusters), pt.size = 0.2, ncol = 1, slot = &quot;counts&quot;, log = TRUE) + NoLegend() } for (i in seq(1, length(features), 2)) { if (c(i+1) &lt;= length(features)) { do.call(grid.arrange, c(plots[i:c(i+1)], ncol = 1, nrow = 2)) } else { do.call(grid.arrange, c(plots[i:length(features)], ncol = 1, nrow = 2)) } } for (f in names(markers_genes)){ print(FeaturePlot(obj_seurat, features = f, dims = c(1, 2), cols = c(&quot;grey90&quot;, brewer.pal(9,&quot;YlGnBu&quot;)), pt.size = 0.2, ncol = 1) + NoLegend()) } plots &lt;- list() for (i in seq(1, length(features))) { plots[[i]] &lt;- FeaturePlot(obj_seurat, features = features[i], cols = c(&quot;grey90&quot;, rev(brewer.pal(5, &quot;Spectral&quot;))), pt.size = 0.2, ncol = 1) + NoLegend() } for (i in seq(1, length(features), 4)) { if (c(i+3) &lt;= length(features)) { do.call(grid.arrange, c(plots[i:c(i+3)], ncol = 2, nrow = 2)) } else { do.call(grid.arrange, c(plots[i:length(features)], ncol = 2, nrow = 2)) } } Here are the contingency tables to visualize how many cells from the different cell types are in each cluster. cont_table_n &lt;- obj_seurat@meta.data %&gt;% group_by(Cell_subtype, seurat_clusters) %&gt;% summarise(n = n()) %&gt;% tidyr::spread(Cell_subtype, n) cont_table_prop &lt;- obj_seurat@meta.data %&gt;% group_by(Cell_subtype, seurat_clusters) %&gt;% summarise(n = n()) %&gt;% mutate(prop = n/sum(n)) %&gt;% subset(select = c(&quot;Cell_subtype&quot;,&quot;seurat_clusters&quot;,&quot;prop&quot;)) %&gt;% tidyr::spread(Cell_subtype, prop) DT::datatable(cont_table_n, extensions = c(&#39;Buttons&#39;, &#39;Scroller&#39;), options = list( dom = &#39;Bfrtip&#39;, buttons = c(&#39;csv&#39;, &#39;pdf&#39;), deferRender = TRUE, scrollY = 200, scrollX = TRUE, scroller = TRUE)) DT::datatable(cont_table_prop, extensions = c(&#39;Buttons&#39;, &#39;Scroller&#39;), options = list( dom = &#39;Bfrtip&#39;, buttons = c(&#39;csv&#39;, &#39;pdf&#39;), deferRender = TRUE, scrollY = 200, scrollX = TRUE, scroller = TRUE)) 3.8 Find DE genes between clusters Idents(obj_seurat) &lt;- &#39;seurat_clusters&#39; markers_DE &lt;- FindAllMarkers(obj_seurat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = &quot;MAST&quot;) markers_DE &lt;- markers_DE %&gt;% filter(p_val &lt; 1e-2) top10 &lt;- markers_DE %&gt;% filter(p_val &lt; 1e-2) %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) DoHeatmap(obj_seurat, features = top10$gene, label = FALSE) + theme(axis.text.y = element_text(size = 3)) 3.9 Find DE genes between subtypes Idents(obj_seurat) &lt;- &#39;Cell_subtype&#39; markers_Subtype &lt;- FindAllMarkers(obj_seurat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = &quot;MAST&quot;) markers_Subtype &lt;- markers_Subtype %&gt;% filter(p_val &lt; 1e-2) top10 &lt;- markers_Subtype %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) DoHeatmap(obj_seurat, features = top10$gene, label = FALSE) + theme(axis.text.y = element_text(size = 4)) 3.10 Find DE genes between SOX2+ and SOX2- populations Idents(obj_seurat) &lt;- &#39;SOX2_status&#39; markers_SOX2 &lt;- FindAllMarkers(obj_seurat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = &quot;MAST&quot;) markers_SOX2 &lt;- markers_SOX2 %&gt;% filter(p_val &lt; 1e-2) top10 &lt;- markers_SOX2 %&gt;% group_by(cluster) %&gt;% top_n(n = 10, wt = avg_log2FC) DoHeatmap(obj_seurat, features = top10$gene, label = FALSE) + theme(axis.text.y = element_text(size = 10)) 3.11 Save data We save data both as RDS objects and TSV table to have a direct access to metadata if needed. For reproducibility or re-analyses purposes, use RDS objects. They can be loaded with the readRDS() command. saveRDS(obj_seurat, file = paste0(&quot;data/rds/&quot;, params$gtf, &quot;_obj_seurat_final.rds&quot;)) saveRDS(obj_sce, file = paste0(&quot;data/rds/&quot;, params$gtf, &quot;_obj_sce.rds&quot;)) saveRDS(markers_DE, file = paste0(&quot;data/rds/&quot;, params$gtf, &quot;_markers_clustering.rds&quot;)) saveRDS(markers_Subtype, file = paste0(&quot;data/rds/&quot;, params$gtf, &quot;_markers_Subtype.rds&quot;)) saveRDS(markers_SOX2, file = paste0(&quot;data/rds/&quot;, params$gtf, &quot;_markers_SOX2.rds&quot;)) # Save metadata on cells write.table(obj_seurat[[]], file = paste0(&quot;data/raw/&quot;, params$gtf, &quot;_cells_metadata.tsv&quot;), quote = FALSE, sep = &quot;\\t&quot;) # Save metadata on genes write.table(obj_seurat@assays$RNA@meta.features, file = paste0(&quot;data/raw/&quot;, params$gtf, &quot;_genes_metadata.tsv&quot;), quote = FALSE, sep = &quot;\\t&quot;) "],["session-info.html", " 4 Session info", " 4 Session info sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 16.04.4 LTS ## ## Matrix products: default ## BLAS/LAPACK: /import/bc_workspaces/csb/lehmann/conda/envs/scRNA/lib/libopenblasp-r0.3.12.so ## ## locale: ## [1] LC_CTYPE=fr_FR.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=fr_FR.UTF-8 LC_COLLATE=fr_FR.UTF-8 ## [5] LC_MONETARY=fr_FR.UTF-8 LC_MESSAGES=fr_FR.UTF-8 ## [7] LC_PAPER=fr_FR.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats4 stats graphics grDevices utils datasets ## [8] methods base ## ## other attached packages: ## [1] ggthemes_4.2.4 scales_1.1.1 ## [3] viridis_0.6.0 viridisLite_0.4.0 ## [5] cowplot_1.1.1 RColorBrewer_1.1-2 ## [7] gridExtra_2.3 scater_1.18.6 ## [9] ggplot2_3.3.3 SingleCellExperiment_1.12.0 ## [11] SummarizedExperiment_1.20.0 Biobase_2.50.0 ## [13] GenomicRanges_1.42.0 GenomeInfoDb_1.26.7 ## [15] IRanges_2.24.1 S4Vectors_0.28.1 ## [17] BiocGenerics_0.36.0 MatrixGenerics_1.2.1 ## [19] matrixStats_0.58.0 dplyr_1.0.5 ## [21] SeuratObject_4.0.0 Seurat_4.0.1 ## ## loaded via a namespace (and not attached): ## [1] circlize_0.4.13 plyr_1.8.6 ## [3] igraph_1.2.6 lazyeval_0.2.2 ## [5] splines_4.0.3 crosstalk_1.1.1 ## [7] BiocParallel_1.24.1 listenv_0.8.0 ## [9] scattermore_0.7 digest_0.6.27 ## [11] htmltools_0.5.1.1 fansi_0.4.2 ## [13] magrittr_2.0.1 tensor_1.5 ## [15] cluster_2.1.1 ROCR_1.0-11 ## [17] globals_0.14.0 spatstat.sparse_2.0-0 ## [19] prettyunits_1.1.1 jpeg_0.1-8.1 ## [21] colorspace_2.0-0 ggrepel_0.9.1 ## [23] xfun_0.22 crayon_1.4.1 ## [25] RCurl_1.98-1.3 jsonlite_1.7.2 ## [27] spatstat.data_2.1-0 survival_3.2-10 ## [29] zoo_1.8-9 glue_1.4.2 ## [31] polyclip_1.10-0 gtable_0.3.0 ## [33] zlibbioc_1.36.0 XVector_0.30.0 ## [35] MatrixModels_0.5-0 leiden_0.3.7 ## [37] DelayedArray_0.16.3 BiocSingular_1.6.0 ## [39] shape_1.4.5 future.apply_1.7.0 ## [41] abind_1.4-5 mvtnorm_1.1-1 ## [43] DBI_1.1.1 miniUI_0.1.1.1 ## [45] Rcpp_1.0.6 progress_1.2.2 ## [47] xtable_1.8-4 reticulate_1.18 ## [49] spatstat.core_2.0-0 rsvd_1.0.5 ## [51] DT_0.18 htmlwidgets_1.5.3 ## [53] httr_1.4.2 ellipsis_0.3.1 ## [55] ica_1.0-2 farver_2.1.0 ## [57] pkgconfig_2.0.3 scuttle_1.0.4 ## [59] sass_0.3.1 uwot_0.1.10 ## [61] deldir_0.2-10 utf8_1.2.1 ## [63] labeling_0.4.2 tidyselect_1.1.0 ## [65] rlang_0.4.10 reshape2_1.4.4 ## [67] later_1.1.0.1 munsell_0.5.0 ## [69] tools_4.0.3 generics_0.1.0 ## [71] ggridges_0.5.3 evaluate_0.14 ## [73] stringr_1.4.0 fastmap_1.1.0 ## [75] yaml_2.2.1 goftest_1.2-2 ## [77] knitr_1.33 fitdistrplus_1.1-3 ## [79] yarrr_0.1.5 purrr_0.3.4 ## [81] RANN_2.6.1 pbapply_1.4-3 ## [83] future_1.21.0 nlme_3.1-152 ## [85] sparseMatrixStats_1.2.1 mime_0.10 ## [87] compiler_4.0.3 rstudioapi_0.13 ## [89] beeswarm_0.3.1 plotly_4.9.3 ## [91] png_0.1-7 spatstat.utils_2.1-0 ## [93] tibble_3.1.0 bslib_0.2.4 ## [95] stringi_1.5.3 highr_0.8 ## [97] RSpectra_0.16-0 lattice_0.20-41 ## [99] Matrix_1.3-2 vctrs_0.3.7 ## [101] pillar_1.6.0 lifecycle_1.0.0 ## [103] GlobalOptions_0.1.2 spatstat.geom_2.1-0 ## [105] lmtest_0.9-38 jquerylib_0.1.3 ## [107] BiocNeighbors_1.8.2 RcppAnnoy_0.0.18 ## [109] data.table_1.14.0 bitops_1.0-6 ## [111] irlba_2.3.3 httpuv_1.5.5 ## [113] patchwork_1.1.1 R6_2.5.0 ## [115] bookdown_0.22 promises_1.2.0.1 ## [117] KernSmooth_2.23-18 BayesFactor_0.9.12-4.2 ## [119] vipor_0.4.5 parallelly_1.24.0 ## [121] codetools_0.2-18 gtools_3.8.2 ## [123] MASS_7.3-53.1 assertthat_0.2.1 ## [125] MAST_1.16.0 withr_2.4.1 ## [127] sctransform_0.3.2 GenomeInfoDbData_1.2.4 ## [129] hms_1.0.0 mgcv_1.8-34 ## [131] grid_4.0.3 rpart_4.1-15 ## [133] beachmat_2.6.4 coda_0.19-4 ## [135] tidyr_1.1.3 rmarkdown_2.7 ## [137] DelayedMatrixStats_1.12.3 Rtsne_0.15 ## [139] shiny_1.6.0 ggbeeswarm_0.6.0 "]]
